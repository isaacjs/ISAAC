<!DOCTYPE html>
<html>
<!--Planet Textures courtesy of James Hastings-Trew, http://planetpixelemporium.com/planets.html -->
	<head>
		<meta charset="UTF-8">
		<title>...eppur si muove.</title>
		<script type = "text/javascript" src = "./external/Three.js"></script>
		<script type = "text/javascript" src = "./external/dat.gui.min.js"></script>
		<script type = "text/javascript" src = "./external/Stats.js"></script>
		
		<script type = "text/javascript" src = "./isaac_obj.js"></script>
		<script type = "text/javascript" src = "./isaac_planets.js"></script>
		<script type = "text/javascript" src = "./isaac_orbit_phys.js"></script>
		
		<style type = "text/css">
			body { 
				margin: 0px; 
				overflow: hidden;
				background-color: black;
			}
			.overlay {
				margin-left: auto;
				margin-right: auto;
				width: 25em;
				position: fixed;
				display: block;

				pointer-events: none;
				z-index: 50;
				padding: 0px 3px 0px 3px;
				border: solid 1px white;
				color: white;

				font-family: Segoe UI, Arial, "MS Trebuchet", sans-serif;
				font-size: 90%;
				text-align: justify;
			}
			.hidden {
				display: none;
			}
		</style>
	</head>
	<body>
		<div class = "hidden" id = "massMultTooltip">This value is multiplied by the original mass of the body.</div>
		<div class = "hidden" id = "timestepTooltip">One second in real time is this amount in the simulation.</div>
		<div class = "hidden" id = "gcmTooltip">
			This value is multiplied by the Gravitational Constant.
			<p>
				The force of gravity between two bodies is given by
				multiplying	the Gravitational Constant by the masses
				of the bodies, then dividing the result by the
				square of the distance between them.
			</p>

			By adjusting the Gravitational Constant, gravitational force
			is changed all throughout the solar system (and the universe!)
		</div>
		<div id="renderArea"></div>
		
		<script type = "text/javascript">
			// Tooltips. So, so hackish >.>
			var massMultShow = function() { document.getElementById("massMultTooltip").className = "overlay"; };
			var massMultHide = function() { document.getElementById("massMultTooltip").className = "hidden"; };
			var timestepShow = function() { document.getElementById("timestepTooltip").className = "overlay"; };
			var timestepHide = function() { document.getElementById("timestepTooltip").className = "hidden"; };
			var gcmShow = function() { document.getElementById("gcmTooltip").className = "overlay"; };
			var gcmHide = function() { document.getElementById("gcmTooltip").className = "hidden"; };

			// Three.js elements.
			var camera, scene, renderer;
			
			// Stats (for debugging)
			var stats;
			
			// Planets and their materials.
			var sunModel, earthModel, marsModel, mercuryModel;
			var jupiterModel, venusModel, neptuneModel, uranusModel, plutoModel, saturnModel;
			var sunMaterial, earthMaterial, marsMaterial, mercuryModel;
			var jupiterMaterial, venusMaterial, neptuneMaterial, uranusMaterial;
			var plutoMaterial, saturnMaterial;
			var planetModels;

			// Point light.
			var light;

			// Camera movement-related variables.
			var isMouseDown = false;
			var middleMouseDown = false;
			var mouseLastX, mouseLastY;
			var cameraAngleX = 0;
			var cameraAngleY = 0;
			var cameraDist = 200;
			var origin = new THREE.Vector3(0, 0, 0);
			var cameraFocus = Sun;
			
			// Web Worker.
			var worker = new Worker('isaac_worker.js');
			
			init();
			
			function init() {
				// ------ GUI Initialisation ------ //
				var gui = new dat.GUI(
				{ width : 500 }
				);

				// Create the Camera folder.
				var cameraSettings = gui.addFolder("Camera");
				cameraSettings.add(window, 'cameraDist', 5, 750).name("Camera Distance").listen();
				cameraSettings.add(config, 'cameraFocus',
					{ 
						"Sun" : 0, 
						"Mercury" : 1, 
						"Venus" : 2,
						"Earth" : 3,
						"Mars" : 4,
						"Jupiter" : 5,
						"Saturn" : 6,
						"Uranus" : 7,
						"Neptune" : 8,
						"Pluto" : 9
					}).name("Camera Focus").listen();
				
				// Create the Simulation Settings folder.
				var simSettings = gui.addFolder("Simulation Settings");
				var upstepDOM = simSettings.add(config, 'updateStep', 
					{ "One Day" : 1, "One Week" : 7, "One Month" : 30, "Three Months" : 90 }).name("Update Step").domElement;
				upstepDOM.onmouseover = timestepShow;
				upstepDOM.onmouseout = timestepHide;

				var gcmDOM = simSettings.add(config, "gravConstMult", 0.1, 10).name("Gravitational Constant Multiplier").domElement;
				gcmDOM.onmouseover = gcmShow;
				gcmDOM.onmouseout = gcmHide;
				
				// Create the Orbital Bodies folder.
				var planetsFolder = gui.addFolder("Orbital Bodies");
				
				// Create the Sun's folder.
				var sunFolder = planetsFolder.addFolder("Sun");
				var sunFoldDOM = (sunFolder.add(Sun.config, "massMult", 0.1, 100).name("Mass Multiplier")).domElement;
				sunFoldDOM.onmouseover = massMultShow;
				sunFoldDOM.onmouseout = massMultHide;
				
				// Create Mercury's folder.
				var mercuryFolder = planetsFolder.addFolder("Mercury");
				var merFoldDOM = mercuryFolder.add(Mercury.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				merFoldDOM.onmouseover = massMultShow;
				merFoldDOM.onmouseout = massMultHide;
				
				// Create Venus' folder.
				var venusFolder = planetsFolder.addFolder("Venus");
				var venFoldDOM = venusFolder.add(Venus.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				venFoldDOM.onmouseover = massMultShow;
				venFoldDOM.onmouseout = massMultHide;

				// Create Earth's folder.
				var earthFolder = planetsFolder.addFolder("Earth");
				var earthFoldDOM = earthFolder.add(Earth.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				earthFoldDOM.onmouseover = massMultShow;
				earthFoldDOM.onmouseout = massMultHide;
				
				// Create Mars' folder.
				var marsFolder = planetsFolder.addFolder("Mars");
				var marsFoldDOM = marsFolder.add(Mars.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				marsFoldDOM.onmouseover = massMultShow;
				marsFoldDOM.onmouseout = massMultHide;
				
				// Create Jupiter's folder.
				var jupiterFolder = planetsFolder.addFolder("Jupiter");
				var jupFoldDOM = jupiterFolder.add(Jupiter.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				jupFoldDOM.onmouseover = massMultShow;
				jupFoldDOM.onmouseout = massMultHide;
				
				// Create Saturn's folder.
				var saturnFolder = planetsFolder.addFolder("Saturn");
				var satFoldDOM = saturnFolder.add(Saturn.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				satFoldDOM.onmouseover = massMultShow;
				satFoldDOM.onmouseout = massMultHide;
				
				// Create Uranus' folder.
				var uranusFolder = planetsFolder.addFolder("Uranus");
				var uraFoldDOM = uranusFolder.add(Uranus.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				uraFoldDOM.onmouseover = massMultShow;
				uraFoldDOM.onmouseout = massMultHide;
				
				// Create Neptune's folder.
				var neptuneFolder = planetsFolder.addFolder("Neptune");
				var nepFoldDOM = neptuneFolder.add(Neptune.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;	
				nepFoldDOM.onmouseover = massMultShow;
				nepFoldDOM.onmouseout = massMultHide;
				
				// Create Pluto's folder.
				var plutoFolder = planetsFolder.addFolder("Pluto");
				var pluFoldDOM = plutoFolder.add(Pluto.config, "massMult", 0.1, 100).name("Mass Multiplier").domElement;
				pluFoldDOM.onmouseover = massMultShow;
				pluFoldDOM.onmouseout = massMultHide;
				
				// ------ End of GUI Initialisation ------ //
				
				// ------ FPS Counter (for debug only) ------ //
				stats = new Stats();
				stats.getDomElement().style.position = 'absolute';
				stats.getDomElement().style.left = '0px';
				stats.getDomElement().style.bottom = '0px';
				
				document.body.appendChild( stats.getDomElement() );
				
				setInterval( function () { stats.update(); }, 1000 / 60 );
				// ------ End of FPS Counter ------ //
				
				// Get the renderArea.
				var renderArea = document.getElementById('renderArea');
				
				// Setup the camera and scene.
				camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 1, 10000);
				camera.position.x = cameraDist;
				camera.lookAt(origin);
				scene = new THREE.Scene();
				scene.add(camera);
				
				// Check if we have WebGL support using a temporary canvas.
				var tempCanvas = document.createElement('canvas');
				var webGLSupport;
				try {
					webGLSupport = window.WebGLRenderingContext && (tempCanvas.getContext("webgl") || tempCanvas.getContext("experimental-webgl"));	
				} catch (x) {
					webGLSupport = false;
				}
				console.log(webGLSupport ? "WebGL supported. Using WebGLRenderer." : "WebGL unsupported. Using CanvasRenderer.");

				// Setup the renderer.
				renderer = webGLSupport ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderArea.appendChild(renderer.domElement);
				renderer.setClearColorHex(0x000000, 1.0);
				renderer.clear();
				
				var meshHide = true;

				// If we have WebGL support, double the amount of segments.
				var webGLMult = webGLSupport ? 2 : 1;

				// If we have WebGL support, use MeshLambertMaterial for everything except the Sun. If not, use MeshBasicMaterial.
				var material = webGLSupport ? THREE.MeshLambertMaterial : THREE.MeshBasicMaterial;

				// Create the Sun.
				sunMaterial = new THREE.MeshBasicMaterial( { map : THREE.ImageUtils.loadTexture('external/planets/sun.jpg'), overdraw : meshHide } );
				sunModel = new THREE.Mesh(new THREE.SphereGeometry(20, 16 * webGLMult, 16 * webGLMult), sunMaterial);
				sunModel.name = "Sun";
				
				// Create the Earth.
				earthMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/earth.jpg'), overdraw : meshHide } );
				earthModel = new THREE.Mesh(new THREE.SphereGeometry(4, 16 * webGLMult, 16 * webGLMult), earthMaterial);
				earthModel.name = "Earth";
				
				// Create Mars.
				marsMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/mars.jpg'), overdraw : meshHide });
				marsModel = new THREE.Mesh(new THREE.SphereGeometry(6, 16 * webGLMult, 16 * webGLMult), marsMaterial);
				marsModel.name = "Mars";
				
				// Create Mercury.
				mercuryMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/mercury.jpg'), overdraw : meshHide });
				mercuryModel = new THREE.Mesh(new THREE.SphereGeometry(2, 8 * webGLMult, 8 * webGLMult), mercuryMaterial);
				mercuryModel.name = "Mercury";
				
				// Create Jupiter.
				jupiterMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/jupiter.jpg'), overdraw : meshHide });
				jupiterModel = new THREE.Mesh(new THREE.SphereGeometry(10, 16 * webGLMult, 16 * webGLMult), jupiterMaterial);
				jupiterModel.name = "Jupiter";
				
				// Create Venus.
				venusMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/venus.jpg'), overdraw : meshHide });
				venusModel = new THREE.Mesh(new THREE.SphereGeometry(4, 16 * webGLMult, 16 * webGLMult), venusMaterial);
				venusModel.name = "Venus";
				
				// Create Neptune.
				neptuneMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/neptune.jpg'), overdraw : meshHide });
				neptuneModel = new THREE.Mesh(new THREE.SphereGeometry(6, 16 * webGLMult, 16 * webGLMult), neptuneMaterial);
				neptuneModel.name = "Neptune";
				
				// Create Uranus.
				uranusMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/uranus.jpg'), overdraw : meshHide });
				uranusModel = new THREE.Mesh(new THREE.SphereGeometry(6, 16 * webGLMult, 16 * webGLMult), uranusMaterial);
				uranusModel.name = "Uranus";
				
				// Create Pluto.
				plutoMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/pluto.jpg'), overdraw : meshHide });
				plutoModel = new THREE.Mesh(new THREE.SphereGeometry(2, 8 * webGLMult, 8 * webGLMult), plutoMaterial);
				plutoModel.name = "Pluto";
				
				// Create Saturn.
				saturnMaterial = new material( { map : THREE.ImageUtils.loadTexture('external/planets/saturn.jpg'), overdraw : meshHide });
				saturnModel = new THREE.Mesh(new THREE.SphereGeometry(8, 16 * webGLMult, 16 * webGLMult), saturnMaterial);
				saturnModel.name = "Saturn";
				
				// Add all the models to an array.
				planetModels = [earthModel, marsModel, sunModel, mercuryModel, jupiterModel, neptuneModel, uranusModel, venusModel, plutoModel, saturnModel];

				// Add everything to the scene.
				scene.add(sunModel);
				scene.add(earthModel);
				scene.add(marsModel);
				scene.add(mercuryModel);
				scene.add(jupiterModel);
				scene.add(neptuneModel);
				scene.add(uranusModel);
				scene.add(venusModel);
				scene.add(saturnModel);
				scene.add(plutoModel);

				// If we have WebGL support, add a PointLight at the Sun.
				if(webGLSupport) {
					light = new THREE.PointLight(0xFFFFFF);
					light.position.x = 0;
					light.position.y = 0;
					light.position.z = 0;
					scene.add(light);
				}
				
				// Render.
				renderer.render(scene, camera);
				
				// Add hooks for mouse events, to move the camera around.
				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mouseup', onDocumentMouseUp, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				
				// Start the worker.
				worker.addEventListener('message', function (e) {
					var data = e.data.response;
					if(typeof data !== 'undefined') {
						Earth.motion.position = data.earthPos;
						Sun.motion.position = data.sunPos;
						Mars.motion.position = data.marsPos;
						Jupiter.motion.position = data.jupiterPos;
						Neptune.motion.position = data.neptunePos;
						Venus.motion.position = data.venusPos;
						Uranus.motion.position = data.uranusPos;
						Saturn.motion.position = data.saturnPos;
						Pluto.motion.position = data.plutoPos;
						Mercury.motion.position = data.mercuryPos;
					}
				}, false);
			}
			
			function animUpdate() {
				// Ping the worker to get updated positions.
				worker.postMessage({'command' : 'get'});
				
				// Update the graphical representations of the objects.
				objUpdate(Earth, earthModel);
				objUpdate(Mars, marsModel);
				objUpdate(Sun, sunModel);
				objUpdate(Mercury, mercuryModel);
				objUpdate(Jupiter, jupiterModel);
				objUpdate(Neptune, neptuneModel);
				objUpdate(Venus, venusModel);
				objUpdate(Uranus, uranusModel);
				objUpdate(Saturn, saturnModel);
				objUpdate(Pluto, plutoModel);

				// Update the position of the light to be that of the Sun.
				if(light) {
					light.position.x = Sun.motion.position[0];
					light.position.y = Sun.motion.position[1];
					light.position.z = Sun.motion.position[2];
				}

				// Update the camera's position.
				// Get the planet to centre the camera on.
				switch(config.cameraFocus){
					case "0": cameraFocus = Sun; break;
					case "1": cameraFocus = Mercury; break;
					case "2": cameraFocus = Venus; break;
					case "3": cameraFocus = Earth; break;
					case "4": cameraFocus = Mars; break;
					case "5": cameraFocus = Jupiter; break;
					case "6": cameraFocus = Saturn; break;
					case "7": cameraFocus = Uranus; break;
					case "8": cameraFocus = Neptune; break;
					case "9": cameraFocus = Pluto; break;					
				}
				// Adjust the camera (horizontal).
				camera.position.x = cameraDist * Math.cos(cameraAngleX * Math.PI / 360);
				camera.position.z = cameraDist * Math.sin(cameraAngleX * Math.PI / 360);
				
				// Adjust the camera (vertical).
				camera.position.y = cameraDist * Math.sin(cameraAngleY * Math.PI / 360);
				camera.position.x *= Math.cos(cameraAngleY * Math.PI / 360);
				camera.position.z *= Math.cos(cameraAngleY * Math.PI / 360);

				// Translate the camera to the planet.
				camera.position.x += cameraFocus.motion.position[0]
				camera.position.z += cameraFocus.motion.position[1]
				camera.position.y += cameraFocus.motion.position[2]

				// Point the camera at the planet.
				camera.lookAt(new THREE.Vector3(cameraFocus.motion.position[0], cameraFocus.motion.position[2], cameraFocus.motion.position[1]));
				
				// Setup continuous updates.
				window.requestAnimationFrame(animUpdate, renderer.domElement);
				
				// Render!
				renderer.render(scene, camera);
			}
			
			animUpdate();
			
			function objUpdate(object, model) {
				model.position.x = object.motion.position[0];
				model.position.y = object.motion.position[2];
				model.position.z = object.motion.position[1];
			}

			// Projector to detect which planet is being clicked.
			var projector = new THREE.Projector();
			
			// Handles mousedown events.
			function onDocumentMouseDown(event) {
				var element;
				// Check if the mouse is over the canvas.
				if(event.target) {
					element = event.target.nodeName;
				}
				
				if(element === 'CANVAS') {
					// Only adjust the camera's position if the mouse was over the canvas and the left-mouse button was clicked.
					if(event.button === 0) {
						isMouseDown = true;

						// Figure out if the mouse clicked any planet.
						var x = event.clientX;
						var y = event.clientY;
						var vector = new THREE.Vector3((x / window.innerWidth) * 2 - 1, -(y / window.innerHeight) * 2 + 1, 0.5);
						projector.unprojectVector(vector, camera);
						var ray = new THREE.Ray(camera.position, vector.subSelf(camera.position).normalize());
						var intersects = ray.intersectObjects(planetModels);
						if(intersects.length > 0) {
							// Move the camera to the planet.
							switch(intersects[0].object.name) {
								case "Sun": config.cameraFocus = "0"; break;
								case "Mercury" : config.cameraFocus = "1"; break;
								case "Venus" : config.cameraFocus = "2"; break;
								case "Earth" : config.cameraFocus = "3"; break;
								case "Mars" : config.cameraFocus = "4"; break;
								case "Jupiter" : config.cameraFocus = "5"; break;
								case "Saturn" : config.cameraFocus = "6"; break;
								case "Uranus" : config.cameraFocus = "7"; break;
								case "Neptune" : config.cameraFocus = "8"; break;
								case "Pluto" : config.cameraFocus = "9"; break;
							}
						}
					}

					// If the middle mouse button is held, flag it.
					if(event.button === 1) {
						middleMouseDown = true;
					}
				}
			}
			
			// Handles mouseup events.
			function onDocumentMouseUp(event) {
				isMouseDown = false;
				middleMouseDown = false;
				
				// Send updated settings to the worker.
				worker.postMessage({
					'command' : 'set', 
					'config' : config, 
					'earthConfig' : Earth.config,
					'sunConfig' : Sun.config,
					'mercuryConfig' : Mercury.config,
					'venusConfig' : Venus.config,
					'neptuneConfig' : Neptune.config,
					'marsConfig' : Mars.config,
					'jupiterConfig' : Jupiter.config,
					'uranusConfig': Uranus.config,
					'saturnConfig' : Saturn.config,
					'plutoConfig' : Pluto.config});
			}
			
			// Handles mousemove events. Used to move the camera.
			function onDocumentMouseMove(event) {
				// Get the position of the mouse.
				var mouseX = event.clientX;
				var mouseY = event.clientY;

				// Get the delta of the mouse's position.
				var mouseXDelta = event.clientX - mouseLastX;
				var mouseYDelta = event.clientY - mouseLastY;

				// Check if the left mouse button is down.
				if(isMouseDown) {
					// Add the corresponding rotation to the camera angle.
					cameraAngleX += mouseXDelta;
					
					// Restrict camera panning to 90 degrees up or down.
					if(cameraAngleY > 175) {
						cameraAngleY = 175;
					} else if(cameraAngleY < -175) {
						cameraAngleY = -175;
					} else {
						cameraAngleY += mouseYDelta;
					}
				} 

				// If middle mouse is down, zoom in or out.
				if(middleMouseDown) {
					// Restrict camera zooming to the same range as the UI allows.
					if(cameraDist > 750) {
						cameraDist = 750;
					} else if(cameraDist < 5) {
						cameraDist = 5;
					} else {
						cameraDist += mouseYDelta;
					}
				}
				mouseLastX = event.clientX;
				mouseLastY = event.clientY;
			}

			// Pause when we aren't visible.
			function pageHidden() {
				worker.postMessage( {'command' : 'pause'} );
			}
			function pageVisible() {
				worker.postMessage( {'command' : 'resume'} );
			}
			// Figure out which Page Visibility handler to use.
			if(typeof document.hidden != "undefined") {
				document.addEventListener("visibilitychange", visibilityHandler);
			} else if (typeof document.webkitHidden != "undefined") {
				document.addEventListener("webkitvisibilitychange", visibilityHandler);
			} else if (typeof document.msHidden != "undefined") {
				document.addEventListener("msvisibilitychange", visibilityHandler);
			} else if (typeof document.mozHidden != "undefined") {
				document.addEventListener("mozvisibilitychange", visibilityHandler);
			}
			// Define the visibility handler.
			function visibilityHandler() {
				if(typeof document.hidden != "undefined") {
					if(document.hidden) {
						pageHidden();
					} else {
						pageVisible();
					}
				} else if (typeof document.webkitHidden != "undefined") {
					if(document.webkitHidden) {
						pageHidden();
					} else {
						pageVisible();
					}
				} else if (typeof document.msHidden != "undefined") {
					if(document.msHidden) {
						pageHidden();
					} else {
						pageVisible();
					}
				} else if (typeof document.mozHidden != "undefined") {
					if(document.mozHidden) {
						pageHidden();
					} else {
						pageVisible();
					}
				}
			}

			// Handle page resizing.
			function pageResize() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				
				renderer.setSize(width, height);
				camera.aspect = width/height;
				camera.updateProjectionMatrix();
			}
			window.addEventListener('resize', pageResize, false);
		</script>
	</body>
</html>
