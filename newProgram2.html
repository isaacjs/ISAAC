<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<title>ISAAC Physics</title>
		<script type="text/javascript" src="o3d-webgl/base.js"></script>
		<script type="text/javascript" src="o3djs/base.js"></script>
		<script type="text/javascript">
			o3djs.base.o3d = o3d;
			o3djs.require('o3djs.webgl');
			o3djs.require('o3djs.util');
			o3djs.require('o3djs.math');
			o3djs.require('o3djs.rendergraph');
			o3djs.require('o3djs.primitives');
			
			// Events - init is called when page is loaded, uninit is called when page is unloaded.
			window.onload = init;
			window.onunload = uninit;
			
			// Global Variables
			var g_o3d;
			var g_math;
			var g_client;
			var g_pack;
			var g_clock = 0;
			var g_timeMult = 1;
			var g_cubeTransform;
			var g_viewInfo;
			var g_3dRoot;
			
			// Function to square a number.
			function square(x) {
				return x * x;
			}
			
			// Function to round a number. Takes in the item to be rounded and the amount of decimal places,
			// returns the item rounded to that amount of decimal places.
			// If the item is an array/vector, every element will be rounded. This function will break if an object
			// that isn't an array/vector is passed to it.
			function round(x, dp) {
				var power = Math.pow(10, dp);
				if(typeof(x) === "object") {
					for(i = 0; i < x.length; i++) {
						x[i] = round(x[i], dp);
					}
					return x;
				}
				
				return (Math.round(x * power) / power);
			}
			
			var Camera = {
				upArray : [0, 0, 1],
				eyeX : 0,
				eyeY : 0,
				eyeZ : 0,
				
				targetX : 0,
				targetY : 1,
				targetZ : 0,
				
				lastXAngle: 90,
				lastYAngle: 90,
				lastZAngle: 0,
				
				// Camera Initialise Method
				initialise: function() {
					this.update({"eyeX" : this.eyeX, "eyeY" : this.eyeY, "eyeZ" : this.eyeZ,
				"targetX" : this.targetX, "targetY" : this.targetY, "targetZ" : this.targetZ});
				},
				
				
				// Camera Update Method
				update: function(newParams) {
					var eyeX, eyeY, eyeZ, targetX, targetY, targetZ, eyeVector, targetVector;
					for(name in newParams) {
						// Round everything off to five decimal places.
						newParams[name] = round(newParams[name], 5);
						
						switch(name) {
							case "eyeX": eyeX = newParams["eyeX"];
							break;
							case "eyeY": eyeY = newParams["eyeY"];
							break;
							case "eyeZ": eyeZ = newParams["eyeZ"];
							break;
							case "targetX": targetX = newParams["targetX"];
							break;
							case "targetY": targetY = newParams["targetY"];
							break;
							case "targetZ": targetZ = newParams["targetZ"];
							break;
							case "eyeVector" : eyeVector = newParams["eyeVector"];
							break;
							case "targetVector" : targetVector = newParams["targetVector"];
							break;
						}
					}
					
					if(typeof(eyeVector) != "undefined") {
						this.eyeX = eyeVector[0];
						this.eyeY = eyeVector[1];
						this.eyeZ = eyeVector[2];
					}
					
					if(typeof(targetVector) != "undefined") {
						this.targetX = targetVector[0];
						this.targetY = targetVector[1];
						this.targetZ = targetVector[2];
					}
					
					// Uses the || operator's handling of falsy values.
					g_viewInfo.drawContext.view = g_math.matrix4.lookAt(
						eyeVector || [eyeX || this.eyeX, eyeY || this.eyeY, eyeZ || this.eyeZ],
						targetVector || [targetX || this.targetX, targetY || this.targetY, targetZ || this.targetZ], 
						this.upArray);
					
					//console.log("Target: " + this.targetX + " " + this.targetY + " " + this.targetZ);
					//console.log("Pos: " + this.eyeX + " " + this.eyeY + " " + this.eyeZ);
					//console.log("Last: " + this.lastXAngle + " " + this.lastYAngle + " " + this.lastZAngle);
				},
				
				
				// Camera Movement Methods
				move: function(amount, direction) {
					var posArray = [this.eyeX, this.eyeY, this.eyeZ];
					var targetArray = [this.targetX, this.targetY, this.targetZ];
					
					var diffVector = g_math.subVector(posArray, targetArray);
					var adjustmentVector = g_math.mulVectorScalar(diffVector, amount);
					var newPos, newTarget;
					
					switch(direction) {
						case "forward":
							newPos = g_math.subVector(posArray, adjustmentVector);
							newTarget = g_math.subVector(targetArray, adjustmentVector);
							break;
						case "back":
							newPos = g_math.addVector(posArray, adjustmentVector);
							newTarget = g_math.addVector(targetArray, adjustmentVector);
							break;
					}
					this.update( {"eyeVector" : newPos, "targetVector" : newTarget});
				},
				
				// Right-handed coordinate system.
				// X is to the right (because we start 90 degrees facing right.)
				// Y is forward (only because we're looking right.)
				// Z is up.
				strafe: function(amount, direction) {
					var posArray = [this.eyeX, this.eyeY, this.eyeZ];
					
					// We want the target point "normalised" to the same height level as our current position.
					var normalisedTarget = [this.targetX, this.targetY, this.eyeZ];
					
					// Get the vector from our current position to the normalised target.
					var posVector = g_math.subVector(posArray, normalisedTarget);
					
					var shiftVector, adjustmentVector, newPos, newTarget;
					
					switch(direction) {
						case "left":
							shiftVector = g_math.cross(posVector, this.upArray);
							break;
						case "right":
							shiftVector = g_math.cross(posVector, g_math.mulVectorScalar(this.upArray, -1));
							break;
					}
					adjustmentVector = g_math.mulVectorScalar(shiftVector, amount);
					
					//console.log("Normal Target: " + normalisedTarget);
					//console.log("Pos to Target: " + posVector);
					//console.log("Cross: " + shiftVector);
					//console.log("Adjustment: " + adjustmentVector);
					
					newPos = g_math.addVector(posArray, adjustmentVector);
					
					//console.log("Added: " + newPos);
					newTarget = g_math.addVector([this.targetX, this.targetY, this.targetZ], adjustmentVector);
					
					this.update( {"eyeVector" : newPos, "targetVector" : newTarget});
				},
				
				moveUp: function(amount) {
					// Calculate the new position and target values.
					this.eyeZ = this.eyeZ + amount;
					this.targetZ = this.targetZ + amount;
					
					// Update the camera position.
					this.update({ "eyeZ" : this.eyeZ, "targetZ" : this.targetZ });
				},
				moveDown: function(amount) {
					// Calculate the new position and target values.
					this.eyeZ = this.eyeZ - amount;
					this.targetZ = this.targetZ - amount;
					
					// Update the camera position.
					this.update({ "eyeZ" : this.eyeZ, "targetZ" : this.targetZ });
				},
				
				// Camera Rotation Methods
				rotate: function(amount, direction){
					// Reset the camera angle if it goes beyond +-180. This is to ensure
					// we don't end up with massive camera angles after a while.
					if(this.lastXAngle >= 180) {
						this.lastXAngle = -180;
					} else if(this.lastXAngle <= -180) {
						this.lastXAngle = 180;
					}
					
					if(this.lastYAngle >= 180) {
						this.lastYAngle = -180;
					} else if(this.lastYAngle <= -180) {
						this.lastYAngle = 180;
					}
					
					var distance = 1;
					var newAngle, cosAmount, sinAmount, newX, newY;

					switch(direction){
						case "left": 
							this.lastXAngle += amount;
							this.lastYAngle += amount;
							cosAmount = Math.cos(g_math.degToRad(this.lastXAngle));
							sinAmount = Math.sin(g_math.degToRad(this.lastYAngle));
							newX = this.eyeX + cosAmount;
							newY = this.eyeY + sinAmount;
							break;
						case "right": 
							this.lastXAngle -= amount;
							this.lastYAngle -= amount;
							cosAmount = Math.cos(g_math.degToRad(this.lastXAngle));
							sinAmount = Math.sin(g_math.degToRad(this.lastYAngle));
							newX = this.eyeX + cosAmount;
							newY = this.eyeY + sinAmount;
							break;
					}
					
					this.update({ "targetVector" : [newX, newY, this.targetZ] });
					//console.log("Amount: " + amount);
					//console.log("Distance: " + distance);
					//console.log("cosAmount: " + cosAmount);
					//console.log("sinAmount: " + sinAmount);
					//console.log("Target X: " + this.targetX);
					//console.log("Target Y: " + this.targetY);
					//console.log("Target Z: " + this.targetZ);
				},
				
				tilt: function(amount, direction) {
					var cosAmount, sinAmount, newX, newY, newZ;
					// Restrict vertical camera angle to 60 degrees.
					switch(direction){
						case "up":
							if(this.lastZAngle >= 60) {
								this.lastZAngle = 60;
							} else {
								this.lastZAngle += amount;
								
								cosAmount = Math.cos(g_math.degToRad(amount));
								sinAmount = Math.sin(g_math.degToRad(this.lastZAngle));
								newZ = this.eyeZ + sinAmount;
								newX = this.targetX * cosAmount;
								newY = this.targetY * cosAmount;
							}
							break;
						case "down":
							if(this.lastZAngle <= -60) {
								this.lastZAngle = -60;
							} else {
								this.lastZAngle -= amount;
							
								cosAmount = Math.cos(g_math.degToRad(-amount));
								sinAmount = Math.sin(g_math.degToRad(this.lastZAngle));
								newZ = this.eyeZ + sinAmount;
								newX = this.targetX * cosAmount;
								newY = this.targetY * cosAmount;
							}
							break;
					}
					// Need to use the falsy-handling system to avoid Undefined being passed to the update method.
					this.update( {"targetVector" : [newX || this.targetX, newY || this.targetY, newZ || this.targetZ]});
				},
				
				
				// The following methods have been deprecated, and are kept here solely for reference.
				// They do not operate correctly and should not be used.
				moveLeft: function(amount) {
					// Calculate the new position and target values.
					this.eyeX = this.eyeX + amount;
					this.targetX = this.targetX + amount;
					
					// Update the camera position.
					this.update({ "eyeX" : this.eyeX, "targetX" : this.targetX });
				},
				moveRight: function(amount) {
					// Calculate the new position and target values.
					this.eyeX = this.eyeX - amount;
					this.targetX = this.targetX - amount;
					
					// Update the camera position.
					this.update({ "eyeX" : this.eyeX, "targetX" : this.targetX });
				},
				moveForward: function(amount) {
					// Calculate the new position and target values.
					this.eyeZ = this.eyeZ - amount;
					this.targetZ = this.targetZ - amount;
					
					// Update the camera position.
					this.update({ "eyeZ" : this.eyeZ, "targetZ" : this.targetZ });
				},
				moveBackward: function(amount) {
					// Calculate the new position and target values.
					this.eyeZ = this.eyeZ + amount;
					this.targetZ = this.targetZ + amount;
					
					// Update the camera position.
					this.update({ "eyeZ" : this.eyeZ, "targetZ" : this.targetZ });
				},
				rotateLeft: function(amount) {
					// Calculate new target value.
					this.targetX = this.targetX - amount;
					
					// Update the camera.
					this.update({ "targetX" : this.targetX });
				},
				rotateRight: function(amount) {
					// Calculate new target value.
					this.targetX = this.targetX + amount;
					
					// Update the camera.
					this.update({ "targetX" : this.targetX });
				},
				rotateUp: function(amount) {
					// Calculate new target value.
					this.targetY = this.targetY + amount;
					
					// Update the camera.
					this.update({ "targetY" : this.targetY });
				},
				rotateDown: function(amount) {
					// Calculate new target value.
					this.targetY = this.targetY - amount;
					
					// Update the camera.
					this.update({ "targetY" : this.targetY });
				}
			};
			
			function renderCallback(renderEvent) {
				g_clock += renderEvent.elapsedTime * g_timeMult;
				
				// Rotate the cube around the X and Y axis.
				//	g_cubeTransform.identity();
				//	g_cubeTransform.rotateY(1.0 * g_clock);
				//	g_cubeTransform.rotateX(2.0 * g_clock);
			}
			
			// Handle keyboard input.
			function keyPressedAction(keyPressed) {
				var actionTaken = false;
				var keyMoveDelta = 0.1;
				var keyRotateDelta = 2;
				
				switch(keyPressed) {
					// Camera Movement Keys
					case 'a': Camera.strafe(keyMoveDelta, "left");
					actionTaken = true;
					break;
					case 'd': Camera.strafe(keyMoveDelta, "right");
					actionTaken = true;  
					break;  
					case 'w': Camera.move(keyMoveDelta, "forward");
					actionTaken = true;  
					break;  
					case 's': Camera.move(keyMoveDelta, "back");
					actionTaken = true;  
					break;
					case 'z': Camera.moveUp(keyMoveDelta);
					actionTaken = true;
					break;  
					case 'x': Camera.moveDown(keyMoveDelta);
					actionTaken = true;
					break;
					
					// Camera Rotation Keys
					case 'j': Camera.rotate(keyRotateDelta, "left");
					actionTaken = true;
					break;
					case 'l' : Camera.rotate(keyRotateDelta, "right");
					actionTaken = true;
					break;
					case 'i' : Camera.tilt(keyRotateDelta, "up");
					actionTaken = true;
					break;
					case 'k' : Camera.tilt(keyRotateDelta, "down");
					actionTaken = true;
					break;
				}  
				return actionTaken;  
			}  
			
			function keyPressedCallback(event) {  
				event = event || window.event;  
				
				if (event.metaKey)  
				return;  
				
				var keyChar = String.fromCharCode(o3djs.event.getEventKeyChar(event));  
				keyChar = keyChar.toLowerCase();  
				
				if (keyPressedAction(keyChar)) {  
					o3djs.event.cancel(event);  
				}  
			}  
			
			// Create the client area.
			function init() {
				o3djs.webgl.makeClients(initStep2);
			}
			
			// Initialise O3D.
			function initStep2(clientElements) {
				// Initializes global variables and libraries.
				var o3dElement = clientElements[0];
				g_client = o3dElement.client;
				g_o3d = o3dElement.o3d;
				g_math = o3djs.math;
				
				// Create a pack to manage the objects created.
				g_pack = g_client.createPack();
				
				// Create a root transform.
				g_3dRoot = g_client.root;
				
				// Create the render graph for a view.
				g_viewInfo = o3djs.rendergraph.createBasicView(
				g_pack,
				g_client.root,
				g_client.renderGraphRoot);
				
				// Set up a perspective projection.
				g_viewInfo.drawContext.projection = g_math.matrix4.perspective(
				g_math.degToRad(90), // 90 degree fov.
				g_client.width / g_client.height,
				1,                  // Near plane.
				5000);              // Far plane.
				
				// Set up our view transformation to look towards the world origin where the
				// cube is located.
				Camera.initialise();
				
				// Create an Effect object and initialize it using the shaders from the
				// text area.
				var redEffect = g_pack.createObject('Effect');
				var vertexShaderString = document.getElementById('vshader').value;
				var pixelShaderString = document.getElementById('pshader').value;
			redEffect.loadVertexShaderFromString(vertexShaderString);
			redEffect.loadPixelShaderFromString(pixelShaderString);
			
			// Create a Material for the mesh.
			var redMaterial = g_pack.createObject('Material');
			
			// Set the material's drawList.
			redMaterial.drawList = g_viewInfo.performanceDrawList;
			
			// Apply our effect to this material. The effect tells the 3D hardware
			// which shaders to use.
			redMaterial.effect = redEffect;
			
			// Create the cube.
			var cubeShape = o3djs.primitives.createCube(g_pack, redMaterial, 2, g_math.matrix4.identity());
			
			// Parent the cube to a new transform.
			g_cubeTransform = g_pack.createObject('Transform');
			g_cubeTransform.addShape(cubeShape);
			
			// Move the cube.
			g_cubeTransform.translate(0, 5, 0);
			
			// Parent the cube's transform to the client root.
			g_cubeTransform.parent = g_client.root;
			
			// Set our render callback for animation.
			// This sets a function to be executed every time a frame is rendered.
			g_client.setRenderCallback(renderCallback);
			
			
			window.document.onkeypress = keyPressedCallback;
			}
			// Cleanup after the page is unloaded.
			function uninit() {
			if(g_client) {
			g_client.cleanup();
			}
			}
			</script>
			</head>
			<body>
			<h1>Rendering Area</h1>
			<div id="o3d" style="width: 800 px; height: 600px;"></div>
			
			<!-- Textarea copied from hellocube -->
			<div style="display:none">
			<!-- Start of effect -->
			<textarea id="vshader">
			// World View Projection matrix that will transform the input vertices
			// to screen space.
			attribute vec4 position;
			
			uniform mat4 world;
			uniform mat4 view;
			uniform mat4 projection;
			
			/**
			* The vertex shader simply transforms the input vertices to screen space.
			*/
			void main() {
			// Multiply the vertex positions by the worldViewProjection matrix to
			// transform them to screen space.
			gl_Position = projection * view * world * position;
			}
			</textarea>
			<textarea id="pshader">
			/**
			* This pixel shader just returns the color red.
			*/
			void main() {
			gl_FragColor = vec4(0, 0, 0, 0);  // Red.
			}
			</textarea>
			<!-- End of effect -->
			</div>
			</body>
			</html>						