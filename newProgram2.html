<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<title>ISAAC Physics</title>
		<script type="text/javascript" src="o3d-webgl/base.js"></script>
		<script type="text/javascript" src="o3djs/base.js"></script>
		<script type="text/javascript">
			o3djs.base.o3d = o3d;
			o3djs.require('o3djs.webgl');
			o3djs.require('o3djs.util');
			o3djs.require('o3djs.math');
			o3djs.require('o3djs.rendergraph');
			o3djs.require('o3djs.primitives');
			
			// Events - init is called when page is loaded, uninit is called when page is unloaded.
			window.onload = init;
			window.onunload = uninit;
			
			// Global Variables
			var g_o3d;
			var g_math;
			var g_client;
			var g_pack;
			var g_clock = 0;
			var g_timeMult = 1;
			var g_cubeTransform;
			var g_viewInfo;
			var g_3dRoot;
			var g_keyPressDelta = 0.1;
			
			// Function to square a number.
			function square(x) {
				return x * x;
			}
			
			var Camera = {
				upArray : [0, 0, 1],
				currX : 0,
				currY : 0,
				currZ : 0,
				
				targetX : 0,
				targetY : 5,
				targetZ : 0,
				
				lastXAngle: Math.PI/2,
				lastYAngle: Math.PI/2,
				lastZAngle: 0,
				
				// Camera Initialise Method
				initialise: function() {
					this.update({"eyeX" : this.currX, "eyeY" : this.currY, "eyeZ" : this.currZ,
				"targetX" : this.targetX, "targetY" : this.targetY, "targetZ" : this.targetZ});
				},
				
				
				// Camera Update Method
				update: function(newParams) {
					var eyeX, eyeY, eyeZ, targetX, targetY, targetZ, eyeVector, targetVector;
					for(name in newParams) {
						switch(name) {
							case "eyeX": eyeX = newParams["eyeX"];
							break;
							case "eyeY": eyeY = newParams["eyeY"];
							break;
							case "eyeZ": eyeZ = newParams["eyeZ"];
							break;
							case "targetX": targetX = newParams["targetX"];
							break;
							case "targetY": targetY = newParams["targetY"];
							break;
							case "targetZ": targetZ = newParams["targetZ"];
							break;
							case "eyeVector" : eyeVector = newParams["eyeVector"];
							break;
							case "targetVector" : targetVector = newParams["targetVector"];
							break;
						}
					}
					
					if(typeof(eyeVector) != "undefined") {
						this.currX = eyeVector[0];
						this.currY = eyeVector[1];
						this.currZ = eyeVector[2];
					}
					
					if(typeof(targetVector) != "undefined") {
						this.targetX = targetVector[0];
						this.targetY = targetVector[1];
						this.targetZ = targetVector[2];
					}
					
					// Uses the || operator's handling of falsy values.
					g_viewInfo.drawContext.view = g_math.matrix4.lookAt(eyeVector || [eyeX || this.currX, eyeY || this.currY, eyeZ || this.currZ],
					targetVector || [targetX || this.targetX, targetY || this.targetY, targetZ || this.targetZ], this.upArray);
					
					console.log("Target: " + this.targetX + " " + this.targetY + " " + this.targetZ);
				console.log("Pos: " + this.currX + " " + this.currY + " " + this.currZ);
				console.log("Last: " + this.lastXAngle + " " + this.lastYAngle + " " + this.lastZAngle);
				},
				
				
				// Camera Movement Methods
				move: function(amount, direction) {
					var posArray = [this.currX, this.currY, this.currZ];
					var targetArray = [this.targetX, this.targetY, this.targetZ];
					
					var diffVector = g_math.subVector(posArray, targetArray);
					var adjustmentVector = g_math.mulVectorScalar(diffVector, amount);
					
					switch(direction) {
						case "forward":
							var newPos = g_math.subVector(posArray, adjustmentVector);
							var newTarget = g_math.subVector(targetArray, adjustmentVector);
							this.update( {"eyeVector" : newPos, "targetVector" : newTarget});
							break;
						case "back":
							var newPos = g_math.addVector(posArray, adjustmentVector);
							var newTarget = g_math.addVector(targetArray, adjustmentVector);
							this.update( {"eyeVector" : newPos, "targetVector" : newTarget});
							break;
					}
				},
				
				moveLeft: function(amount) {
					// Calculate the new position and target values.
					this.currX = this.currX + amount;
					this.targetX = this.targetX + amount;
					
					// Update the camera position.
					this.update({ "eyeX" : this.currX, "targetX" : this.targetX });
				},
				moveRight: function(amount) {
					// Calculate the new position and target values.
					this.currX = this.currX - amount;
					this.targetX = this.targetX - amount;
					
					// Update the camera position.
					this.update({ "eyeX" : this.currX, "targetX" : this.targetX });
				},
				moveUp: function(amount) {
					// Calculate the new position and target values.
					this.currY = this.currY + amount;
					this.targetY = this.targetY + amount;
					
					// Update the camera position.
					this.update({ "eyeY" : this.currY, "targetY" : this.targetY });
				},
				moveDown: function(amount) {
					// Calculate the new position and target values.
					this.currY = this.currY - amount;
					this.targetY = this.targetY - amount;
					
					// Update the camera position.
					this.update({ "eyeY" : this.currY, "targetY" : this.targetY });
				},
				moveForward: function(amount) {
					// Calculate the new position and target values.
					this.currZ = this.currZ - amount;
					this.targetZ = this.targetZ - amount;
					
					// Update the camera position.
					this.update({ "eyeZ" : this.currZ, "targetZ" : this.targetZ });
				},
				moveBackward: function(amount) {
					// Calculate the new position and target values.
					this.currZ = this.currZ + amount;
					this.targetZ = this.targetZ + amount;
					
					// Update the camera position.
					this.update({ "eyeZ" : this.currZ, "targetZ" : this.targetZ });
				},
				
				// Camera Rotation Methods
				rotate: function(amount, direction){
					//var distance = Math.floor(Math.sqrt(square(this.targetX - this.currX) + square(this.targetY - this.currY) + square(this.targetZ - this.currZ)));
					var distance = 1;
					var newAngle, cosAmount, sinAmount;
					//var cosAmount = Math.cos(amount) * distance;
					//var sinAmount = Math.sin(amount) * distance;
					switch(direction){
						case "left": 
						this.lastXAngle += amount;
						this.lastYAngle += amount;
						cosAmount = Math.cos(this.lastXAngle);
						sinAmount = Math.sin(this.lastYAngle);
						this.targetX = this.currX + cosAmount;
						this.targetY = this.currY + sinAmount;
						break;
						case "right": 
						this.lastXAngle -= amount;
						this.lastYAngle -= amount;
						cosAmount = Math.cos(this.lastXAngle);
						sinAmount = Math.sin(this.lastYAngle);
						this.targetX = this.currX + cosAmount;
						this.targetY = this.currY + sinAmount;
						break;
						case "up": 
						this.lastXAngle += amount;
						this.lastZAngle += amount;
						cosAmount = Math.cos(this.lastZAngle);
						sinAmount = Math.sin(this.lastXAngle);
						this.targetZ = this.currZ + cosAmount;
						this.targetX = this.currX + sinAmount;
						break;
						case "down": this.targetY = this.currY - cosAmount;
						this.targetZ = this.currZ + sinAmount;
						break;
					}
					
					this.update({ "targetX" : this.targetX,
						"targetY" : this.targetY,
						"targetZ" : this.targetZ
					});
					//console.log("Amount: " + amount);
					//console.log("Distance: " + distance);
					//console.log("cosAmount: " + cosAmount);
					//console.log("sinAmount: " + sinAmount);
					//console.log("Target X: " + this.targetX);
					//console.log("Target Y: " + this.targetY);
					//console.log("Target Z: " + this.targetZ);
				},
					
				rotateLeft: function(amount) {
					// Calculate new target value.
					this.targetX = this.targetX - amount;
					
					// Update the camera.
					this.update({ "targetX" : this.targetX });
				},
				rotateRight: function(amount) {
					// Calculate new target value.
					this.targetX = this.targetX + amount;
					
					// Update the camera.
					this.update({ "targetX" : this.targetX });
				},
				rotateUp: function(amount) {
					// Calculate new target value.
					this.targetY = this.targetY + amount;
					
					// Update the camera.
					this.update({ "targetY" : this.targetY });
				},
				rotateDown: function(amount) {
					// Calculate new target value.
					this.targetY = this.targetY - amount;
					
					// Update the camera.
					this.update({ "targetY" : this.targetY });
				}
			};
			
			function renderCallback(renderEvent) {
				g_clock += renderEvent.elapsedTime * g_timeMult;
				
				// Rotate the cube around the X and Y axis.
				//	g_cubeTransform.identity();
				//	g_cubeTransform.rotateY(1.0 * g_clock);
				//	g_cubeTransform.rotateX(2.0 * g_clock);
			}
			
			// Handle keyboard input.
			function keyPressedAction(keyPressed, delta) {
				var actionTaken = false;
				
				switch(keyPressed) {
					// Camera Movement Keys
					case 'a': Camera.moveLeft(delta);
					actionTaken = true;
					break;
					case 'd': Camera.moveRight(delta);
					actionTaken = true;  
					break;  
					case 'w': Camera.move(delta, "forward");
					actionTaken = true;  
					break;  
					case 's': Camera.move(delta, "back");
					actionTaken = true;  
					break;
					case 'z': Camera.moveUp(delta);
					actionTaken = true;
					break;  
					case 'x': Camera.moveDown(delta);
					actionTaken = true;
					break;
					
					// Camera Rotation Keys
					case 'j': Camera.rotate(delta, "left");
					actionTaken = true;
					break;
					case 'l' : Camera.rotate(delta, "right");
					actionTaken = true;
					break;
					case 'i' : Camera.rotate(delta, "up");
					actionTaken = true;
					break;
					case 'k' : Camera.rotate(delta, "down");
					actionTaken = true;
					break;
				}  
				return actionTaken;  
			}  
			
			function keyPressedCallback(event) {  
				event = event || window.event;  
				
				if (event.metaKey)  
				return;  
				
				var keyChar =String.fromCharCode(o3djs.event.getEventKeyChar(event));  
				keyChar = keyChar.toLowerCase();  
				
				if (keyPressedAction(keyChar, g_keyPressDelta)) {  
					o3djs.event.cancel(event);  
				}  
			}  
			
			// Create the client area.
			function init() {
				o3djs.webgl.makeClients(initStep2);
			}
			
			// Initialise O3D.
			function initStep2(clientElements) {
				// Initializes global variables and libraries.
				var o3dElement = clientElements[0];
				g_client = o3dElement.client;
				g_o3d = o3dElement.o3d;
				g_math = o3djs.math;
				
				// Create a pack to manage the objects created.
				g_pack = g_client.createPack();
				
				// Create a root transform.
				g_3dRoot = g_client.root;
				
				// Create the render graph for a view.
				g_viewInfo = o3djs.rendergraph.createBasicView(
				g_pack,
				g_client.root,
				g_client.renderGraphRoot);
				
				// Set up a perspective projection.
				g_viewInfo.drawContext.projection = g_math.matrix4.perspective(
				g_math.degToRad(90), // 90 degree fov.
				g_client.width / g_client.height,
				1,                  // Near plane.
				5000);              // Far plane.
				
				// Set up our view transformation to look towards the world origin where the
				// cube is located.
				Camera.initialise();
				
				// Create an Effect object and initialize it using the shaders from the
				// text area.
				var redEffect = g_pack.createObject('Effect');
				var vertexShaderString = document.getElementById('vshader').value;
				var pixelShaderString = document.getElementById('pshader').value;
			redEffect.loadVertexShaderFromString(vertexShaderString);
			redEffect.loadPixelShaderFromString(pixelShaderString);
			
			// Create a Material for the mesh.
			var redMaterial = g_pack.createObject('Material');
			
			// Set the material's drawList.
			redMaterial.drawList = g_viewInfo.performanceDrawList;
			
			// Apply our effect to this material. The effect tells the 3D hardware
			// which shaders to use.
			redMaterial.effect = redEffect;
			
			// Create the cube.
			var cubeShape = o3djs.primitives.createCube(g_pack, redMaterial, 2, g_math.matrix4.identity());
			
			// Parent the cube to a new transform.
			g_cubeTransform = g_pack.createObject('Transform');
			g_cubeTransform.addShape(cubeShape);
			
			// Move the cube.
			g_cubeTransform.translate(0, 5, 0);
			
			// Parent the cube's transform to the client root.
			g_cubeTransform.parent = g_client.root;
			
			// Set our render callback for animation.
			// This sets a function to be executed every time a frame is rendered.
			g_client.setRenderCallback(renderCallback);
			
			
			window.document.onkeypress = keyPressedCallback;
			}
			// Cleanup after the page is unloaded.
			function uninit() {
			if(g_client) {
			g_client.cleanup();
			}
			}
			</script>
			</head>
			<body>
			<h1>Rendering Area</h1>
			<div id="o3d" style="width: 800 px; height: 600px;"></div>
			
			<!-- Textarea copied from hellocube -->
			<div style="display:none">
			<!-- Start of effect -->
			<textarea id="vshader">
			// World View Projection matrix that will transform the input vertices
			// to screen space.
			attribute vec4 position;
			
			uniform mat4 world;
			uniform mat4 view;
			uniform mat4 projection;
			
			/**
			* The vertex shader simply transforms the input vertices to screen space.
			*/
			void main() {
			// Multiply the vertex positions by the worldViewProjection matrix to
			// transform them to screen space.
			gl_Position = projection * view * world * position;
			}
			</textarea>
			<textarea id="pshader">
			/**
			* This pixel shader just returns the color red.
			*/
			void main() {
			gl_FragColor = vec4(0, 0, 0, 0);  // Red.
			}
			</textarea>
			<!-- End of effect -->
			</div>
			</body>
			</html>						